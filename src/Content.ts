import { Observable } from '@reactivex/rxjs';
import { ODataApi } from './ODataApi';
import { ODataHelper } from './ODataHelper';
import { Fields } from './Fields';
import { FieldSettings } from './FieldSettings';
import { Schemas } from './Schema';
import { Security } from './Security';

/**
 * Top level base type of Sense/Net's Type hierarchy.
 *
 * Content has the basic properties and functionality that can be reached on all of the inherited types. It's almost the same as an abstract class, it may not be instantiated directly,
 * but it has the basic methods implemented that can be called on obejcts with derived types.
 *
 * Unlike other Content Types it is not autogenerated.
 * 
 * Actions
 * ------------------
 * 
 * Built-in SenseNet Actions on client-side are methods on the Content object. If you want to use them you have to have a Content which can be made with the Create method that can convert your js Object or JSON
 * with the proper parameters to a Content with the given type. 
 * ```
 * var content = Content.Create('Folder', {DisplayName: 'My folder'});
 * ```
 * On a Content object the Actions can be called like this way (check below sections for further information about the Actions and their params):
 * ```
 * let contentDelete = content.Delete(false);
 * ``` 
 * This function returns an Observable so that you can subscribe to it in your code. This way you can work with the response easier defining the three functions of a subscribtion and
 * using all the super helpful and usable features like filtering, combining, caching, etc. 
 * ```
 * contentDelete.subscribe({
 *  .map(response => response.d) //map and use the reponse's 'd' object as the response 
 *  .subscribe({
 *      next: response => console.log(response), //if the request was successful
 *      error: error => console.error('something wrong occurred: ' + error), //if the request failed
 *      complete: () => console.log('done'), //if the request is done
 *  })
 * });
 * ```
 * Using RxJS you are able to merge, zip or combine multiple Observables, this way you can develope various combinations of Actions with custom functionality.
 * 
 * Read more about RxJS [here](http://reactivex.io/rxjs)
 * 
 * And about Reactive Programming [here](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754) it could be helpful not only with ajax request but also with event handling or anything else
 * related to async data streams.
 */
export class Content {
    Id: number;
    Name?: string;
    Type: string = 'GenericContent';
    DisplayName?: string;
    Description?: string;
    Icon?: string;
    IsFolder?: boolean;
    Path?: string;
    Index?: number;
    CreationDate?: string; //TODO
    ModificationDate?: string; //TODO dÃ¡tum

    /**
     * @constructs Content
     * @param options {Object} An object implementing IContentOptions interface;
     */
    constructor(options: IContentOptions) {
        this.Id = options.Id;
        this.Type = options.Type;
        this.Name = options.Name;
        this.DisplayName = options.DisplayName;
        this.ModificationDate = options.ModificationDate;
        this.CreationDate = options.CreationDate;
        this.Description = options.Description;
        this.Icon = options.Icon;
        this.IsFolder = options.IsFolder;
        this.Path = options.Path;
        this.Index = options.Index;
    }

    /**
     * Deletes a content item from the Content Repository (by default the Content is moved to the Trash). 
     * @param permanently {boolean} Determines if the Content should be deleted permanently or moved to the Trash.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let delContent = content.Delete(false);
     * delContent.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    Delete(permanently: boolean = false): Observable<any> {
        return ODataApi.DeleteContent(this.Id, permanently);
    }
    /**
     * Modifies the DisplayName or the DisplayName and the Name of a content item in the Content Repository.
     * @params newDisplayName {string} New display name of the content.
     * @params newName {string=} New name of the content.
     * @params options {Object=} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let rename = content.Rename('New Title');
     * rename.subscribe({
     *  next: response => {
     *      console.log(response);
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
     */
    Rename(newDisplayName: string, newName?: string, options?: Object) {
        let fields = {};
        if (typeof newDisplayName !== 'undefined') {
            fields['DisplayName'] = newDisplayName;
        }
        if (typeof newName !== 'undefined') {
            fields['Name'] = newName;
        }
        return ODataApi.PatchContent(this.Id, fields);
    }
    /**
     * Saves the content with its given modified fields to the Content Repository.
     * @params fields {Object} Object with the fields that have to be modified.
     * @params override {boolean=} [false] Determines whether clear the fields that are not given (true) or leave them and modify only the given fields (false).
     * @params options {Object=} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let save = content.Save({'Index':2}, true); //Set Index field's value to 2 and clear the rest of the fields.
     * save.subscribe({
     *  next: response => {
     *      console.log(response);
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
     */
    Save(fields: Object, override: boolean = false, options?: Object) {
        if (override) {
            return ODataApi.PutContent(this.Id, fields);
        }
        else {
            return ODataApi.PatchContent(this.Id, fields);
        }
    }
    /**
     * Returns the Content Type Schema of the Content.
     * @returns {FieldSettings.FieldSetting[]} Array of fieldsettings.
     *```ts
     * let schema = SenseNet.Content.GetSchema('GenericContent');
     *```
     */
    GetSchema(): FieldSettings.FieldSetting[] {
        return Schemas[`${this.Type}CTD`]();
    }
    /**
     * Method that returns actions of a content.
     * @params options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let actions = content.Actions('ListItem');
     * actions.subscribe({
     *  next: response => {
     *      console.log(response);
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
     */
    Actions(scenario?: string): Observable<any> {
        let options = {};
        if (typeof scenario !== 'undefined') {
            options = {
                'scenario': scenario
            }
        }
        let optionList;
        if (typeof this.Id !== 'undefined') {
            optionList = this.deferredFunctionBuilder(this.Id, 'Actions', options);
        }
        else {
            optionList = this.deferredFunctionBuilder(this.Path, 'Actions', options);
        }
        return ODataApi.GetContent(optionList);
    }
    /**
     * Method that returns allowed child type list of a content.
     * @params options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let allowedChildTypes = content.GetAllowedChildTypes();
     * allowedChildTypes.subscribe({
     *  next: response => {
     *      console.log(response);
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
     */
    GetAllowedChildTypes(options?: Object): Observable<any> {
        let optionList = this.deferredFunctionBuilder(this.Id, 'AllowedChildTypes', options ? options : null);
        return ODataApi.GetContent(optionList);
    }
    /**
     * Method that returns effective allowed child type list of a content.
     * @params options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let allowedChildTypes = content.GetEffectiveAllowedChildTypes();
     * allowedChildTypes.subscribe({
     *  next: response => {
     *      console.log(response);
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
     */
    GetEffectiveAllowedChildTypes(options?: Object): Observable<any> {
        let optionList = this.deferredFunctionBuilder(this.Id, 'EffectiveAllowedChildTypes', options ? options : null);
        return ODataApi.GetContent(optionList);
    }
    /**
     * Method that returns owner of a content.
     * @params options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let owner = content.GetOwner({select: ['FullName']});
     * owner.subscribe({
     *  next: response => {
     *      console.log(response);
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
     */
    GetOwner(options?: Object): Observable<any> {
        let optionList = this.deferredFunctionBuilder(this.Id, 'Owner', options ? options : null);
        return ODataApi.GetContent(optionList);
    }
    /**
     * Method that returns creator of a content.
     * @params options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let creator = content.Creator({select: ['FullName']});
     * creator.subscribe({
     *  next: response => {
     *      console.log(response);
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
     */
    Creator(options?: Object): Observable<any> {
        let optionList = this.deferredFunctionBuilder(this.Id, 'CreatedBy', options ? options : null);
        return ODataApi.GetContent(optionList);
    }
    /**
     * Method that returns last modifier of a content.
     * @params options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let modifier = content.Modifier({select: ['FullName']});
     * modifier.subscribe({
     *  next: response => {
     *      console.log(response);
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
     */
    Modifier(options?: Object): Observable<any> {
        let optionList = this.deferredFunctionBuilder(this.Id, 'ModifiedBy', options ? options : null);
        return ODataApi.GetContent(optionList);
    }
    /**
     * Method that returns the user who checked-out the content.
     * @params options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let checkedOutBy = content.CheckedOutBy({select: ['FullName']});
     * checkedOutBy.subscribe({
     *  next: response => {
     *      console.log(response);
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
     */
    CheckedOutBy(options?: Object): Observable<any> {
        let optionList = this.deferredFunctionBuilder(this.Id, 'CheckedOutTo', options ? options : null);
        return ODataApi.GetContent(optionList);
    }
    /**
     * Method that returns the children of a content.
     *
     * Calls the method [FetchContent]{@link ODataApi.FetchContent} with the contents id and the given OData options.
     * If you leave the options undefined only the Id and the Type fields will be in the response. These two fields are always the part of the reponse whether they're added or not to the options 
     * as selectable.
     * @params options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let children = content.Children({select: ['DisplayName']});
     * children.subscribe({
     *  next: response => {
     *      console.log(response);
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
     */
    Children(options?: Object): Observable<any> {
        let optionList = this.deferredFunctionBuilder(this.Id, '', options ? options : null);
        return ODataApi.FetchContent(optionList);
    }
    /**
     * Returns the list of versions. 
     *
     * Calls the method [GetContent]{@link ODataApi.GetContent} with the contents id and the given OData options.
     * If you leave the options undefined only the Id and the Type fields will be in the response. These two fields are always the part of the reponse whether they're added or not to the options 
     * as selectable.
     * @params options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let versions = content.Versions();
     * versions.subscribe({
     *  next: response => {
     *      console.log(response);
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    Versions(options?: Object): Observable<any> {
        let optionList = this.deferredFunctionBuilder(this.Id, 'Versions', options ? options : null);
        return ODataApi.GetContent(optionList);
    }
    /**
     * Returns the current Workspace. 
     *
     * Calls the method [GetContent]{@link ODataApi.GetContent} with the contents id and the given OData options.
     * If you leave the options undefined only the Id and the Type fields will be in the response. These two fields are always the part of the reponse whether they're added or not to the options 
     * as selectable.
     * @params options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let currentWorkspace = content.Workspace();
     * currentWorkspace.subscribe({
     *  next: response => {
     *      console.log(response);
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    Workspace(options?: Object): Observable<any> {
        let optionList = this.deferredFunctionBuilder(this.Id, 'Workspace', options ? options : null);
        return ODataApi.GetContent(optionList);
    }
    /**
     * Checkouts a content item in the Content Repository. 
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let checkoutContent = content.Checkout();
     * checkoutContent.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    Checkout(): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'CheckOut', id: this.Id, isAction: true })
        return ODataApi.CreateCustomAction(action);
    }
    /**
     * Checkins a content item in the Content Repository. 
     * @params checkInComments {string=}
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let checkinContent = content.Checkin();
     * checkinContent.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    CheckIn(checkInComments?: string): Observable<any> {
        let action;
        (typeof checkInComments !== '') ?
            action = new ODataApi.CustomAction({ name: 'CheckIn', id: this.Id, isAction: true, params: ['checkInComments'] }) :
            action = new ODataApi.CustomAction({ name: 'CheckIn', id: this.Id, isAction: true });
        return ODataApi.CreateCustomAction(action, { data: { 'checkInComments': checkInComments ? checkInComments : '' } });
    }
    /**
     * Performs an undo check out operation on a content item in the Content Repository. 
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let undoCheckoutContent = content.UndoCheckout();
     * undoCheckoutContent.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    UndoCheckout(): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'UndoCheckOut', id: this.Id, isAction: true })
        return ODataApi.CreateCustomAction(action);
    }
    /**
     * Performs a force undo check out operation on a content item in the Content Repository. 
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let forceUndoCheckoutContent = content.ForceUndoCheckout();
     * forceUndoCheckoutContent.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    ForceUndoCheckout(): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'ForceUndoCheckout', id: this.Id, isAction: true });
        return ODataApi.CreateCustomAction(action);
    }
    /**
     * Performs an approve operation on a content, the equivalent of calling Approve() on the Content instance in .NET. Also checks whether the content handler of the subject content 
     * inherits GenericContent (otherwise it does not support this operation). This action has no parameters. 
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let approveContent = content.Approve();
     * approveContent.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    Approve(): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'Approve', id: this.Id, isAction: true });
        return ODataApi.CreateCustomAction(action);
    }
    /**
     * Performs a reject operation on a content, the equivalent of calling Reject() on the Content instance in .NET. Also checks whether the content handler 
     * of the subject content inherits GenericContent (otherwise it does not support this operation). The reject reason can be supplied in an optional parameter called rejectReason.
     * @params rejectReason {string}
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let rejectContent = content.Reject();
     * rejectContent.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    Reject(rejectReason?: string): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'Reject', id: this.Id, isAction: true, params: ['rejectReason'] });
        return ODataApi.CreateCustomAction(action, { data: { 'rejectReason': rejectReason ? rejectReason : '' } });
    }
    /**
     * Performs a publish operation on a content, the equivalent of calling Publish() on the Content instance in .NET. Also checks whether the content handler of the subject content 
     * inherits GenericContent (otherwise it does not support this operation). This action has no parameters.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let publishContent = content.Publish();
     * publishContent.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    Publish(rejectReason?: string): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'Publish', id: this.Id, isAction: true });
        return ODataApi.CreateCustomAction(action);
    }
    /**
     * Restores an old version of the content. Also checks whether the content handler of the subject content inherits GenericContent (otherwise it does not support this operation). 
     * This action has a single parameter called version where the caller can specify which old version to restore.
     * @params version {string} Old version to restore.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let restoreVersion = content.RestoreVersion();
     * restoreVersion.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    RestoreVersion(version: string): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'Publish', id: this.Id, isAction: true, requiredParams: ['version'] });
        return ODataApi.CreateCustomAction(action, { data: { 'version': version ? version : '' } });
    }
    /**
     * Restores a deleted content from the Trash. You can call this action only on a TrashBag content that contains the deleted content itself.
     * @params destination {string=} Path of the target container, where the deleted content will be restored. If it is not provided, the system uses the original path stored on the trash bag content.
     * @params newname {boolean=} whether to generate a new name automatically if a content with the same name already exists in the desired container (e.g. mydocument(1).docx).
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let restoreContent = content.Restore();
     * restoreContent.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    Restore(destination?: string, newname?: boolean): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'Restore', id: this.Id, isAction: true, params: ['destination', 'newname'] });
        return ODataApi.CreateCustomAction(action, {
            data: {
                'destination': destination ? destination : '',
                'newname': newname ? newname : ''
            }
        });
    }
    /**
     * Copies one content to another container by a given path. 
     * @params Path {string}
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let moveContent = content.MoveTo('/Root/Sites/Default_Site/NewsDemo/Internal');
     * moveContent.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    MoveTo(path: string): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'MoveTo', id: this.Id, isAction: true, requiredParams: ['targetPath'] });
        return ODataApi.CreateCustomAction(action, { data: { 'targetPath': path ? path : '' } });
    }
    /**
     * Copies one content to another container by a given path. 
     * @params Path {string}
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let copyContent = content.CopyTo('/Root/Sites/Default_Site/NewsDemo/Internal');
     * copyContent.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    CopyTo(path: string): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'CopyTo', id: this.Id, isAction: true, requiredParams: ['targetPath'] });
        return ODataApi.CreateCustomAction(action, { data: { 'targetPath': path ? path : '' } });
    }
    /**
     * Adds the given content types to the Allowed content Type list. 
     * @params contentTypes {string[]} A list of the case sensitive content type names.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let setAllowedChildTypes = content.AddAllowedChildTypes(['Folder','ContentList']]);
     * setAllowedChildTypes.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    AddAllowedChildTypes(contentTypes: string[]): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'AddAllowedChildTypes', id: this.Id, isAction: true, requiredParams: ['contentTypes'] });
        return ODataApi.CreateCustomAction(action, { data: { 'contentTypes': contentTypes } });
    }
    /**
     * Removes the given content types from the Allowed content Type list. If the list after removing and the list on the matching CTD are the same, the local list will be removed. 
     * @params contentTypes {string[]} A list of the case sensitive content type names.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let removeAllowedChildTypes = content.RemoveAllowedChildTypes(['Folder','ContentList']]);
     * removeAllowedChildTypes.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    RemoveAllowedChildTypes(contentTypes: string[]): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'RemoveAllowedChildTypes', id: this.Id, isAction: true, requiredParams: ['contentTypes'] });
        return ODataApi.CreateCustomAction(action, { data: { 'contentTypes': contentTypes } });
    }
    /**
     * Requests a Content by the given url.
     * @param path {string} A string containing the URL to which the request is sent.
     * @param options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```ts
     * var content = SenseNet.Content.Load('workspaces/project/budapestprojectworkspace', { select: 'DisplayName' });
     * content
     *     .map(response => response.d)
     *     .subscribe({
     *        next: response => {
     *            //do something with the response
     *        },
     *        error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *        complete: () => console.log('done'),
     * })
     * ```
     */
    public static Load(path: string, options?: Object): Observable<any>;
    /**
     * Requests a Content by the given id.
     * @param id {number} Id of the requested Content.
     * @param options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```ts
     * var content = SenseNet.Content.Load(1234, { expand: 'Avatar' });
     * content
     *     .map(response => response.d)
     *     .subscribe({
     *        next: response => {
     *            //do something with the response
     *        },
     *        error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *        complete: () => console.log('done'),
     * })
     * ```
     */
    public static Load(id: number, options?: Object): Observable<any>;
    /**
     * Requests a Content by the given url and versionnumber.
     * @param path {string} A string containing the URL to which the request is sent.
     * @param version {string} A string containing the version of the requested Content.
     * @param options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```ts
     * var content = SenseNet.Content.Load('workspaces/project/budapestprojectworkspace', 'A.1', { select: 'DisplayName' });
     * content
     *     .map(response => response.d)
     *     .subscribe({
     *        next: response => {
     *            //do something with the response
     *        },
     *        error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *        complete: () => console.log('done'),
     * })
     * ```
     */
    public static Load(path: string, options?: Object, version?: string): Observable<any>;
    /**
     * Requests a Content by the given id.
     * @param id {number} Id of the requested Content.
     * @param version {string} A string containing the version of the requested Content.
     * @param options {Object} JSON object with the possible ODATA parameters like select, expand, etc.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```ts
     * var content = SenseNet.Content.Load(1234, 'A.1', { expand: 'Avatar' });
     * content
     *     .map(response => response.d)
     *     .subscribe({
     *        next: response => {
     *            //do something with the response
     *        },
     *        error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *        complete: () => console.log('done'),
     * })
     * ```
     */
    public static Load(id: number, options?: Object, version?: string): Observable<any>;
    public static Load(arg: any, options?: Object, version?: string): Observable<any> {
        let o = {};
        if (typeof options !== 'undefined') {
            o['params'] = options;
        }
        if (typeof arg === 'string') {
            let contentURL = ODataHelper.getContentURLbyPath(arg);
            o['path'] = contentURL;
            let optionList = new ODataApi.ODataRequestOptions(o as ODataApi.ODataRequestOptions);
            return ODataApi.GetContent(optionList);
        }
        else if (typeof arg === 'number') {
            let contentURL = ODataHelper.getContentUrlbyId(arg);
            o['path'] = contentURL;
            let optionList = new ODataApi.ODataRequestOptions(o as ODataApi.ODataRequestOptions);

            return ODataApi.GetContent(optionList);
        }
    }

    /**
     * Returns the Content Type Schema of the given Content Type;
     * @param type {string} The name of the Content Type;
     * @returns {FieldSettings.FieldSetting[]}
     * ```ts
     * var genericContentSchema = SenseNet.Content.getSchema('GenericContent'); // genericContentSchema is an array of FieldSettings
     * ```
     */
    public static GetSchema(type: string): FieldSettings.FieldSetting[] {
        return Schemas[`${type}CTD`]();
    }

    /**
     * Creates a Content object by the given type and options Object that hold the field values.
     * @param type {string} The Content will be a copy of the given type.
     * @param options {SenseNet.IContentOptions} Optional list of fields and values.
     * @returns {SenseNet.Content}
     * ```ts
     * var content = SenseNet.Content.Create('Folder', { DisplayName: 'My folder' }); // content is an instance of the Folder with the DisplayName 'My folder'
     * ```
     */
    public static Create<T>(type: string, options: IContentOptions = {}): Content {
        options['Type'] = type;
        let content = new Content(options);
        return content;
    }
    /**
     * Returns the Content Type Schema of the Content;
     * @returns {FieldSettings.FieldSetting[]}
     * ```ts
     * var schema = content.Schema();
     * ```
     */
    Schema(): FieldSettings.FieldSetting[] {
        return Schemas[`${this.Type}CTD`]();
    }
    /**
     * Sets permissions on the requested content. You can add or remove permissions for one ore more users or groups using this action or even break/unbreak permission inheritance.
     * @param identities {Security.PermissionRequestBody[]} Permission entry list: array of permission entry objects, containing an identity Id or Path and one or more permission 
     * settings for permission types (see examples below).
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     * ```
     * let myPermissionRequestBody = new Security.PermissionRequestBody[
     *       {identity:"/Root/IMS/BuiltIn/Portal/Visitor", OpenMinor:"allow", Save:"deny"},
     *       {identity:"/Root/IMS/BuiltIn/Portal/Creators", Custom16:"A", Custom17:"1"}
     * ];
     * let setPermissions = content.SetPermissions(myPermissionRequestBody);
     * setPermissions.subscribe({
     *  next: response => {
     *      console.log('success');
     *  },
     *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
     *  complete: () => console.log('done'),
     * });
     * ```
    */
    SetPermissions(identities: Security.PermissionRequestBody[]): Observable<any>;
    /**
    * Sets permissions on the requested content. You can add or remove permissions for one ore more users or groups using this action or even break/unbreak permission inheritance.
    * @param inheritance {Security.Inheritance} inheritance: break or unbreak
    * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let setPermissions = content.SetPermissions({inheritance:"break"});
    * setPermissions.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
   */
    SetPermissions(inheritance: Security.Inheritance): Observable<any>;
    SetPermissions(arg: any): Observable<any> {
        let action;
        if (arg instanceof Array) {
            action = new ODataApi.CustomAction({ name: 'SetPermissions', id: this.Id, isAction: true, requiredParams: ['entryList'] });
            return ODataApi.CreateCustomAction(action, { data: { 'entryList': arg } });
        }
        else {
            action = new ODataApi.CustomAction({ name: 'SetPermissions', path: this.Path, isAction: true, requiredParams: ['inheritance'] });
            return ODataApi.CreateCustomAction(action, { data: { 'entryList': arg } });
        }
    };
    /**
     * Gets permissions for the requested content. If no identity is given, all the permission entries will be returned.
     * 
     * Required permissions to call this action: See permissions.
     * @params identity {string=} path of the identity whose permissions must be returned (user, group or organizational unit)
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let getPermissions = content.GetPermission('/Root/Sites/Default_Site/workspaces/Project/budapestprojectworkspace/Groups/Members');
    * getPermissions.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    GetPermission(identity?: string): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'GetPermission', id: this.Id, isAction: false, params: ['identity'] });
        return ODataApi.CreateCustomAction(action, { data: { 'identity': identity ? identity : '' } });
    }
    /**
     * Gets if the given user (or if it is not given than the current user) has the specified permissions for the requested content.
     * 
     * Required permissions to call this action: See permissions.
     * @params permissions {string[]} list of permission names (e.g. Open, Save)
     * @params user {string} [CurrentUser] path of the user
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let hasPermission = content.HasPermission(['AddNew', 'Save']);
    * hasPermission.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    HasPermission(permissions: string[], user?: string, ): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'HasPermission', id: this.Id, isAction: false, requiredParams: ['permissions'], params: ['user'] });
        return ODataApi.CreateCustomAction(action, { data: { 'permissions': permissions, 'user': user ? user : '' } });
    }
    /**
     * Users who have TakeOwnership permission for the current content can modify the Owner of this content.
     * @params userOrGroup {string} path or the id of the new owner (that can be a Group or a User). The input parameter also supports empty or null string, 
     * in this case the new owner will be the current user.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let takeOwnerShip = content.TakeOwnership({'userGroup':'/Root/IMS/BuiltIn/Portal/Admin'});
    * takeOwnerShip.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    TakeOwnership(userOrGroup?: string): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'TakeOwnership', id: this.Id, isAction: true, params: ['userOrGroup'] });
        return ODataApi.CreateCustomAction(action, { data: { 'userOrGroup': userOrGroup ? userOrGroup : '' } });
    }
    /**
     * Creates or modifies a {Query} content. Use this action instead of creating query content directly using the basic OData create method, because query content can be saved 
     * under a workspace or to the user's profile as a private query.
     * @params query {string} Query text, composed in Query Builder or written manually (see Query syntax for more details). 
     * @params displayName {string} Desired display name for the query content. Can be empty.
     * @params queryType {Fields.SavedQueryType} [Public] Type of the saved query. If an empty value is posted, the default is Public.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let saveQuery = content.SaveQuery({
    *    'query':'DisplayName:Africa',
    *    'displayName': 'My query',
    *    'queryType': 'Private'
    * });
    * saveQuery.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    SaveQuery(query: string, displayName: string, queryType: Fields.SavedQueryType): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'SaveQuery', id: this.Id, isAction: true, requiredParams: ['query', 'displayName', 'queryType'] });
        return ODataApi.CreateCustomAction(action, { data: { 'query': query, 'displayName': displayName ? displayName : '', queryType: queryType } });
    }
    /**
     * Gets Query content that are relevant in the current context. The result set will contain two types of content:
     * * Public queries: query content in the Queries content list of the current workspace.
     * * Private queries: query content in the Queries content list under the profile of the current user
     * @params onlyPublic {boolean} if true, only public queries are returned from the current workspace.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let getQueries = content.GetQueries(true);
    * getQueries.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    GetQueries(onlyPublic: boolean = true): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'GetQueries', id: this.Id, isAction: false, noCache: true, requiredParams: ['onlyPublic'] });
        return ODataApi.CreateCustomAction(action, { data: { 'onlyPublic': onlyPublic } });
    }
    /**
     * Closes a Multistep saving operation and sets the saving state of a content to Finalized. Can be invoked only on content that are not already finalized.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let finalize = content.FinalizeContent(true);
    * finalize.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    Finalize(): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'FinalizeContent', id: this.Id, isAction: true });
        return ODataApi.CreateCustomAction(action);
    }
    /**
    * Lets administrators take over the lock of a checked out document from another user. A new locker user can be provided using the 'user' parameter (user path or id as string). 
    * If left empty, the current user will take the lock.
    * @params userId {number=}
    * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let takeLockOver = content.TakeLockOver(true);
    * takeLockOver.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    TakeLockOver(userId?: number): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'TakeLockOver', id: this.Id, isAction: true, params: ['user'] });
        return ODataApi.CreateCustomAction(action, { data: { 'user': userId ? userId : '' } });
    }
    /**
     * These actions perform an indexing operation on a single content or a whole subtree.
     * @params recursive {boolean=}
     * @params rebuildLevel {number=}
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let rebuildIndex = content.RebuildIndex(true);
    * rebuildIndex.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    RebuildIndex(recursive?: boolean, rebuildLevel?: number): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'RebuildIndex', id: this.Id, isAction: true, params: ['recursive', 'rebuildLevel'] });
        return ODataApi.CreateCustomAction(action, { data: { 'recursive': recursive ? recursive : false, 'rebuildLevel': rebuildLevel ? rebuildLevel : 0 } });
    }
    /**
     * Performs a full reindex operation on the content and the whole subtree.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let rebuildIndexSubtree = content.RebuildIndexSubtree();
    * rebuildIndexSubtree.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    RebuildIndexSubtree(): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'RebuildIndexSubtree', id: this.Id, isAction: true });
        return ODataApi.CreateCustomAction(action);
    }
    /**
     * Refreshes the index document of the content and the whole subtree using the already existing index data stored in the database.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let refreshIndexSubtree = content.RefreshIndexSubtree();
    * refreshIndexSubtree.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    RefreshIndexSubtree(): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'RefreshIndexSubtree', id: this.Id, isAction: true });
        return ODataApi.CreateCustomAction(action);
    }
    /**
     * Returns the number of currently existing preview images. If necessary, it can make sure that all preview images are generated and available for a document.
     * @ params generateMissing {boolean=}
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let checkPreviews = content.CheckPreviews(true);
    * checkPreviews.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    CheckPreviews(generateMissing?: boolean): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'CheckPreviews', id: this.Id, isAction: true, params: ['generateMissing'] });
        return ODataApi.CreateCustomAction(action, { data: { 'generateMissing': generateMissing ? generateMissing : false } });
    }
    /**
     * It clears all existing preview images for a document and starts a task for generating new ones. This can be useful in case the preview status of a document has been set to 'error' 
     * before for some reason and you need to force the system to re-generate preview images.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let regeneratePreviews = content.RegeneratePreviews();
    * regeneratePreviews.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    RegeneratePreviews(): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'RegeneratePreviews', id: this.Id, isAction: true });
        return ODataApi.CreateCustomAction(action);
    }
    /**
     * Returns the number of pages in a document. If there is no information about page count on the content, it starts a preview generation task to determine the page count.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let getPageCount = content.GetPageCount();
    * getPageCount.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    GetPageCount(): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'GetPageCount', id: this.Id, isAction: true });
        return ODataApi.CreateCustomAction(action);
    }
    /**
     * Gets information about a preview image generated for a specific page in a document. It returns with the path and the dimensions (width/height) of the image. If the image does not exist yet, 
     * it returns with an empty object but it starts a background task to generate that image if a valid page count number was determined'ââ. If page count is -1 you need to call GetPageCount action 
     * first. It is OK to call this method periodically for checking if an image is already available.
     * @params page {number}
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let previewAvailable = content.PreviewAvailable(2);
    * previewAvailable.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    PreviewAvailable(page: number): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'PreviewAvailable', id: this.Id, isAction: false, requiredParams: ['page'] });
        return ODataApi.CreateCustomAction(action, { data: { 'page': page } });
    }
    /**
     * Returns the full list of preview images as content items. This method synchronously generates all missing preview images.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let getPreviewImagesForOData = content.GetPreviewImagesForOData();
    * getPreviewImagesForOData.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    GetPreviewImagesForOData(): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'GetPreviewImagesForOData', id: this.Id, isAction: false });
        return ODataApi.CreateCustomAction(action);
    }
    /**
     * Returns the list of existing preview images (only the first consecutive batch) as objects with a few information (image path, dimensions). It does not generate any new images.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let getExistingPreviewImagesForOData = content.GetExistingPreviewImagesForOData();
    * getExistingPreviewImagesForOData.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    GetExistingPreviewImagesForOData(): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'GetExistingPreviewImagesForOData', id: this.Id, isAction: false });
        return ODataApi.CreateCustomAction(action);
    }
    /**
     * Returns the list of the AllowedChildTypes which are set on the current Content.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let getAllowedChildTypesFromCTD = content.GetAllowedChildTypesFromCTD();
    * getAllowedChildTypesFromCTD.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    GetAllowedChildTypesFromCTD(): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'GetAllowedChildTypesFromCTD', id: this.Id, isAction: false });
        return ODataApi.CreateCustomAction(action);
    }
    /**
     * Identity list that contains every users/groups/organizational units that have any permission setting (according to permission level) in the subtree of the context content.
     * @params level {Security.PermissionLevel}  The value is "AllowedOrDenied". "Allowed" or "Denied" are not implemented yet.
     * @params kind {Security.IdentityKind} The value can be: All, Users, Groups, OrganizationalUnits, UsersAndGroups, UsersAndOrganizationalUnits, GroupsAndOrganizationalUnits
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let getRelatedIdentities = content.GetRelatedIdentities("AllowedOrDenied", "Groups");
    * getRelatedIdentities.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    GetRelatedIdentities(level: Security.PermissionLevel, kind: Security.IdentityKind): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'GetRelatedIdentities', id: this.Id, isAction: true, requiredParams: ['level', 'kind'] });
        return ODataApi.CreateCustomAction(action, { data: { 'level': level, 'kind': kind } });
    }
    /**
     * Permission list of the selected identity with the count of related content. 0 indicates that this permission has no related content so the GUI does not have to display it as a tree node
     * @params level {Security.PermissionLevel}  The value is "AllowedOrDenied". "Allowed" or "Denied" are not implemented yet.
     * @params explicitOnly {boolean} The value "true" is required because "false" is not implemented yet.
     * @params member {string} Fully qualified path of the selected identity (e.g. /Root/IMS/BuiltIn/Portal/Visitor).
     * @params includedTypes {string[]} An item can increment the counters if its type or any ancestor type is found in the 'includedTypes'. Null means filtering off. If the array is empty, there 
     * is no element that increases the counters. This filter can reduce the execution speed dramatically so do not use if it is possible.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let getRelatedPermissions = content.GetRelatedPermissions("AllowedOrDenied", true, "/Root/IMS/BuiltIn/Portal/EveryOne", null);
    * getRelatedPermissions.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    GetRelatedPermissions(level: Security.PermissionLevel, explicitOnly: boolean, member: string, includedTypes: string[]): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'GetRelatedPermissions', id: this.Id, isAction: true, requiredParams: ['level', 'explicitOnly', 'member', 'includedTypes'] });
        return ODataApi.CreateCustomAction(action, { data: { 'level': level, 'explicitOnly': explicitOnly, 'member': member, 'includedTypes': includedTypes } });
    }
    /**
     * Content list that have explicite/effective permission setting for the selected user in the current subtree.
     * @params level {Security.PermissionLevel}  The value is "AllowedOrDenied". "Allowed" or "Denied" are not implemented yet.
     * @params explicitOnly {boolean} The value "true" is required because "false" is not implemented yet.
     * @params member {string} Fully qualified path of the selected identity (e.g. /Root/IMS/BuiltIn/Portal/Visitor).
     * @params permissions {string[]} related permission list. Item names are case sensitive. In most cases only one item is used (e.g. "See" or "Save" etc.) but you can pass any permission 
     * type name (e.g. ["Open","Save","Custom02"]).
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let getRelatedItems = content.GetRelatedItems("AllowedOrDenied", true, "/Root/IMS/BuiltIn/Portal/EveryOne", ["RunApplication"]);
    * getRelatedItems.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    GetRelatedItems(level: Security.PermissionLevel, explicitOnly: boolean, member: string, permissions: string[]): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'GetRelatedItems', id: this.Id, isAction: true, requiredParams: ['level', 'explicitOnly', 'member', 'permissions'] });
        return ODataApi.CreateCustomAction(action, { data: { 'level': level, 'explicitOnly': explicitOnly, 'member': member, 'permissions': permissions } });
    }
    /**
     * This structure is designed for getting tree of content that are permitted or denied for groups/organizational units in the selected subtree. The result content are not in a paged list: 
     * they are organized in a tree.
     * @params level {Security.PermissionLevel}  The value is "AllowedOrDenied". "Allowed" or "Denied" are not implemented yet.
     * @params kind {Security.IdentityKind} The value can be: All, Users, Groups, OrganizationalUnits, UsersAndGroups, UsersAndOrganizationalUnits, GroupsAndOrganizationalUnits
     * @params permissions {string[]} related permission list. Item names are case sensitive. In most cases only one item is used (e.g. "See" or "Save" etc.) but you can pass any permission 
     * type name (e.g. ["Open","Save","Custom02"]).
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let getRelatedIdentitiesByPermissions = content.GetRelatedIdentitiesByPermissions("AllowedOrDenied", "Groups", ["RunApplication"]);
    * getRelatedIdentitiesByPermissions.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    GetRelatedIdentitiesByPermissions(level: Security.PermissionLevel, kind: Security.IdentityKind, permissions: string[]): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'GetRelatedIdentitiesByPermissions', id: this.Id, isAction: true, requiredParams: ['level', 'kind', 'permissions'] });
        return ODataApi.CreateCustomAction(action, { data: { 'level': level, 'kind': kind, 'permissions': permissions } });
    }
    /**
     * This structure is designed for getting tree of content that are permitted or denied for groups/organizational units in the selected subtree. The result content are not in a paged list: 
     * they are organized in a tree.
     * @params level {Security.PermissionLevel}  The value is "AllowedOrDenied". "Allowed" or "Denied" are not implemented yet.
     * @params member {string} Fully qualified path of the selected identity (e.g. /Root/IMS/BuiltIn/Portal/Visitor).
     * @params permissions {string[]} related permission list. Item names are case sensitive. In most cases only one item is used (e.g. "See" or "Save" etc.) but you can pass any permission 
     * type name (e.g. ["Open","Save","Custom02"]).
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let getRelatedItemsOneLevel = content.GetRelatedItemsOneLevel("AllowedOrDenied", "/Root/IMS/BuiltIn/Portal/Visitor", ["Open", "RunApplication"]);
    * getRelatedItemsOneLevel.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    GetRelatedItemsOneLevel(level: Security.PermissionLevel, member: string, permissions: string[]): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'GetRelatedItemsOneLevel', id: this.Id, isAction: true, requiredParams: ['level', 'member', 'permissions'] });
        return ODataApi.CreateCustomAction(action, { data: { 'level': level, 'member': member, 'permissions': permissions } });
    }
    /**
     * Returns a content collection that represents users who have enough permissions to a requested resource. The permissions effect on the user and through direct or indirect group membership 
     * too. The function parameter is a permission name list that must contain at least one item.
     * @params permissions {string[]} related permission list. Item names are case sensitive. In most cases only one item is used (e.g. "See" or "Save" etc.) but you can pass any permission 
     * type name (e.g. ["Open","Save","Custom02"]).
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let getAllowedUsers = content.GetAllowedUsers(["Open", "RunApplication"]);
    * getAllowedUsers.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    GetAllowedUsers(permissions: string[]): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'GetAllowedUsers', id: this.Id, isAction: true, requiredParams: ['permissions'] });
        return ODataApi.CreateCustomAction(action, { data: { 'permissions': permissions } });
    }
    /**
     * Returns a content collection that represents groups where the given user or group is member directly or indirectly. This function can be used only on a resource content that is 
     * Group or User or any inherited type. If the value of the "directOnly" parameter is false, all indirect members are listed. 
     * @params directOnly {boolean} If the value of the "directOnly" parameter is false, all indirect members are listed.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let getParentGroups = content.GetParentGroups(["Open", "RunApplication"]);
    * getParentGroups.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    GetParentGroups(directOnly: boolean): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'GetParentGroups', id: this.Id, isAction: true, requiredParams: ['directOnly'] });
        return ODataApi.CreateCustomAction(action, { data: { 'directOnly': directOnly } });
    }
    /**
     * Administrators can add new members to a group using this action. The list of new members can be provided using the 'contentIds' parameter (list of user or group ids). 
     * @params contentIds {number[]} List of the member ids.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let addMembers = content.AddMembers([ 123, 456, 789 ]);
    * addMembers.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    AddMembers(contentIds: number[]): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'AddMembers', id: this.Id, isAction: true, requiredParams: ['contentIds'] });
        return ODataApi.CreateCustomAction(action, { data: { 'contentIds': contentIds } });
    }
    /**
     * Administrators can remove members from a group using this action. The list of removable members can be provided using the 'contentIds' parameter (list of user or group ids). 
     * @params contentIds {number[]} List of the member ids.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
    * ```
    * let removeMembers = content.RemoveMembers([ 123, 456, 789 ]);
    * removeMembers.subscribe({
    *  next: response => {
    *      console.log('success');
    *  },
    *  error: error => console.error('something wrong occurred: ' + error.responseJSON.error.message.value),
    *  complete: () => console.log('done'),
    * });
    * ```
     */
    RemoveMembers(contentIds: number[]): Observable<any> {
        let action = new ODataApi.CustomAction({ name: 'RemoveMembers', id: this.Id, isAction: true, requiredParams: ['contentIds'] });
        return ODataApi.CreateCustomAction(action, { data: { 'contentIds': contentIds } });
    }
    private deferredFunctionBuilder(id: number, fieldName: string, options: Object);
    private deferredFunctionBuilder(path: string, fieldName: string, options: Object);
    private deferredFunctionBuilder(arg, fieldName, options) {
        let contentURL;
        if(typeof arg === 'string'){
            contentURL = ODataHelper.getContentURLbyPath(arg);
        }
        else {
            contentURL = ODataHelper.getContentUrlbyId(arg);
        }
        let o = {};
        if (options) {
            o['params'] = options;
        }
        o['path'] = `${contentURL}/${fieldName}`;
        let optionList = new ODataApi.ODataRequestOptions(o as ODataApi.ODataRequestOptions);
        return optionList;
    }
    /**
     * Uploads a stream or text to a content binary field (e.g. a file).
     * @params ContentType {string=} Specific content type name for the uploaded content. If not provided, the system will try to determine it from the current environment: the upload content types configured in the 
     * web.config and the allowed content types in the particular folder. In most cases, this will be File.
     * @params FileName {string} Name of the uploaded file.
     * @params Overwrite {bool=True} Whether the upload action should overwrite a content if it already exist with the same name. If false, a new file will be created with a similar name containing an 
     * incremental number (e.g. sample(2).docx).
     * @params UseChunk {bool=False} Determines whether the system should start a chunk upload process instead of saving the file in one round. Usually this is determined by the size of the file. 
     * It's optional, used in the first request
     * @params PropertyName {string=Binary} Appoints the binary field of the content where the data should be saved.
     * @params ChunkToken {string} The response of first request returns this token. It must be posted in all of the subsequent requests without modification. It is used for executing the chunk upload operation. 
     * It's mandatory, except in the first request
     * @params {FileText} In case you do not have the file as a real file in the file system but a text in the browser, you can provide the raw text in this parameter.
     * @returns {Observable} Returns an RxJS observable that you can subscribe of in your code.
     */
    public Upload(contentType: string, fileName: string, overwrite?: boolean, useChunk?: boolean, propertyName?: string, fileText?: string): Observable<any> {
        const o = overwrite ? overwrite : true;
        const data = {
            ContentType: contentType,
            FileName: fileName,
            Overwrite: o,
            UseChunk: useChunk ? useChunk : false
        };
        if (typeof propertyName !== 'undefined') {
            data['PropertyName'] = propertyName;
        }
        if (typeof fileText !== 'undefined') {
            data['FileText'] = fileText;
        }
        let uploadCreation = ODataApi.Upload(this.Path, data, true);
        uploadCreation.subscribe({
            next: (response) => {
                const data = {
                    ContentType: contentType,
                    FileName: fileName,
                    Overwrite: o,
                    ChunkToken: response
                };
                return ODataApi.Upload(this.Path, data, false);
            }
        });
        return uploadCreation;
    }
}

/**
* Interface for classes that represent a Content.
*
* @interface IContentOptions
*/

export interface IContentOptions {
    Type?: string;
    Name?: string;
    Id?: number;
    DisplayName?: string;
    Description?: string;
    Icon?: string;
    Index?: number;
    CreationDate?: string;
    ModificationDate?: string;
    IsFolder?: boolean;
    Path?: string;
}